#------------------------------------------------------------------------
#COde to analyse differences in SARS-coV2 genomes
#------------------------------------------------------------------------

#Written by Nick Fountain-Jones (Nick.FountainJones@utas.edu.au) with help from Xavier Didelot and Erik VOlz

library(treeio)
library(ggtree)
library(tidyverse)
library(treestructure) 
library(phylodyn)# needs to options(buildtools.check = function(action) TRUE ) before installing from Git
library(skygrowth)
library(coda)
library(ape)
library(treedater)
library(lubridate)

#------------------------------------------------------------------------
##################Treedater method##################
#------------------------------------------------------------------------

# first we need an unrooted maximum likelihood undated tree. We used PhyML ot generate this tree

tr<-unroot(read.tree('covid_alignment_refinedUpdatedBeligiumSNPs_noErrrorsB.fasta.treefile'))
plot(tr)

#rooted version
tre <- read.tree('covid_alignment_refinedUpdatedBeligiumSNPs_noErrrorsB.fasta.treefile')

RIGHT = function(x,n){
  substring(x,nchar(x)-n+1)
}
# second we need a named vector containing the dates of the genomes in decimal years. assuming this is contained as a suffix of the tip labels, we can extract this using:

dates<-ymd(RIGHT(tr$tip.label, 10))
dateD <- decimal_date(dates)
names(dateD)<-tr$tip.label

# third we need in the alignment length
l<-29442

#test for relaxed clock
rctest <- relaxedClockTest(tr, dateD,l, nreps = 100, overrideTempConstraint = T,
                 ncpu = 1) #uncorrelated clock is best supported
print(rctest )

resPoly <-dater( tr, dateD, l, clock = c("uncorrelated")) 
#basic plot
plot(resPoly, no.mar=T, cex = .2 )

#look for temporal signal
rootToTipRegressionPlot(resPoly) #double check outliers 
par(mfrow=c(1,1))
goodnessOfFitPlot(resPoly) 

class(resPoly) <- 'phylo'
write.tree(resPoly, "treeDaterTestTree")

print(resPoly)
str(resPoly)

#calculate MRCA

pbwPoly <- parboot(resPoly, ncpu = 1, nreps = 1000) #these results make sense. Takes 4 hours to run
par(mar=c(5.1,4.1,4.1,2.1))
plot(pbwPoly, ggplot=TRUE) #plots lineages through time

#-----------------------------------------------------------------------
##################Look for non-random tree structure using treestructure (Volz et al)##################
#------------------------------------------------------------------------

#try min 10 for clade size 
treeSt <-  trestruct(resPoly, minCladeSize = 145, minOverlap = -Inf, nsim = 10000,
                     level = 0.05, ncpu = 1, verbosity = 1) 

treeSt_df <- as.data.frame(treeSt)

plot(treeSt, use_ggtree = TRUE) #overlay these gruops on the tree

#compare to BEAST MCC tree


BEASTtre <-read.nexus('covid_alignment_refinedUpdatedrelaxedClock2.tre')
ggtree(BEASTtre) + geom_tiplab(size=3)
treeStBEAST <-  trestruct(BEASTtre , minCladeSize = 100, minOverlap = -Inf, nsim = 10000,
                     level = 0.05, ncpu = 1, verbosity = 1) 


plot(treeStBEAST, use_ggtree = TRUE) 

#----------------------------
#Subset tree - to three lineages and plot each lineage
#---------------------------

#Lineage A

tokeepc1<-setdiff(resPoly$tip.label,names(treeSt$clustering)[which(treeSt$clustering==2)]) 
Clade1nex<-drop.tip(resPoly,tokeepc1)

# going forward in the tree to remove weird outliers
ggtree(Clade1nex) + geom_tiplab(size=2)

Clade1_names <- as.data.frame(get_taxa_name(tree_view = NULL, node = NULL))

#Lineage B

tokeepc2<-setdiff(resPoly$tip.label,names(treeSt$clustering)[which(treeSt$clustering==3)])

Clade2nex<-drop.tip(resPoly,tokeepc2)

#basic tree
ggtree(Clade2nex) + geom_tiplab(size=2)

Clade2_names <- as.data.frame(get_taxa_name(tree_view = NULL, node = NULL))
Clade2_names$seq <- as.factor(Clade1_names$seq)

Clade2_names$seq <- gsub(("'"), (""), Clade1_names$seq)

#Lineage C

tokeepc3<-setdiff(resPoly$tip.label,names(treeSt$clustering)[which(treeSt$clustering==1)])
Clade3nex<-drop.tip(resPoly,tokeepc3)

ggtree(Clade3nex) + geom_tiplab(size=3)


Clade3_names <- as.data.frame(get_taxa_name(tree_view = NULL, node = NULL))

#---------------------------------------------------------------------------------------------------
##################Treestructure test: test if two clades were generated by the same coalescent process################## 
#--------------------------------------------------------------------------------------------------

#test if A/B different from each other

t1 <- treestructure.test(resPoly, tokeepc1, tokeepc2, nsim = 1000000)
t1
#test if A/C different from each other

t2 <- treestructure.test(resPoly, tokeepc1, tokeepc3, nsim = 10000000)
t2
#test if A/B different from each other
t3 <- treestructure.test(resPoly, tokeepc2, tokeepc3, nsim = 10000000)
t3


#---------------------------------------------------------------------------------------------------
##################Compare treeStructure across BEAST posterior trees: Experimental currently################## 
#--------------------------------------------------------------------------------------------------

allTrees <- scan(file="covid_pdatedrelaxedClock1.trees.txt", what="", sep="\n", quiet=TRUE) #read in .trees file

#check how many trees are stored
allTrees 

burnIn <- 400; index1 = which(grepl("tree STATE_0 ",allTrees)) + burnIn #10% burnIn

samplingFrequency <- (length(allTrees)-index1)/100 #sample 100 of those trees

#
allTrees1 <- allTrees[1:(which(grepl("tree STATE_0 ",allTrees))-1)] #tip names
allTrees2 <- c(allTrees[seq(((index1-1)+samplingFrequency),length(allTrees),samplingFrequency)],"End;") #tree info
#can write this as an object which could be useful
write(c(allTrees1,allTrees2), "covid_updatedrelaxedClock1_100.trees")

#read Multiphy object

library(ape)
beastSubset <- read.nexus('covid_updatedrelaxedClock1_100.trees') #probably an easier way to do this

#check to see if works
ggtree(beastSubset[6]) + geom_tiplab(size=2)+ geom_text2(aes(subset=!isTip, label=node), hjust=-.3) 

#--------------------------------------------------
#multiphyltree structure function
MultiPhyloTreeStructure <- function(beastSub, minCladeSize = 145, minOverlap = -Inf, nsim = 1000,
                                    level = 0.05, ncpu = 1, verbosity = 1){
  
  lp <- length(beastSub)

  
  lapply(lapply(seq(1, lp), function(phy){
    
    treeSt <- trestruct(beastSubset[[phy]], minCladeSize = minCladeSize, minOverlap = minOverlap, nsim = nsim,
              level =  level, ncpu = ncpu, verbosity = verbosity )
    
    treeSt 
    #treeSt_df <- as.data.frame(treeSt)
    
    #plot(treeSt, use_ggtree = TRUE) #overlay these gruops on the tree
    }))
}  
#--------------------------------------------------

 mTS <- MultiPhyloTreeStructure(beastSubset, minCladeSize = 150, minOverlap = -Inf, nsim = 1000,
                                level = 0.1, ncpu = 1, verbosity = 1) #not working properly but works enough
 #Error in match.fun(FUN) : argument "FUN" is missing, with no default 
 
 #look at some individual trees in the posterior and plot
 treeSt1 <- trestruct(beastSubset[[100]], minCladeSize = 150, minOverlap = -Inf, nsim = 10000,
                      level = 0.05, ncpu = 1, verbosity = 1) 
 plot(treeSt1)
 
 treeSt2 <- trestruct(beastSubset[[99]], minCladeSize = 150, minOverlap = -Inf, nsim = 10000,
                      level = 0.05, ncpu = 1, verbosity = 1) 
 plot(treeSt2)
 
 treeSt3 <- trestruct(beastSubset[[2]], minCladeSize = 150, minOverlap = -Inf, nsim = 10000,
                      level = 0.05, ncpu = 1, verbosity = 1) 
 plot(treeSt3)
 
 treeSt4 <- trestruct(beastSubset[[6]], minCladeSize = 150, minOverlap = -Inf, nsim = 10000,
                      level = 0.05, ncpu = 1, verbosity = 1) 
 plot(treeSt4)
 #problem is that node label vary with each iteration...

#------------------------------------------------------------------------
##################Skygrowth models and phylodynn effective pop size##################
#------------------------------------------------------------------------


#--------------------------------------------------------------
#Global models (ie. using all sequences rather than partitions)
#--------------------------------------------------------------

globalgrowth <- skygrowth.mcmc(resPoly, res = 35, tau0=0.1,tau_logprior = function (x) dexp(x,0.1,T), mhsteps= 2e+07, control=list(thin=1e3) ) 

#check convergence
globalMCMC <- as.mcmc(cbind(globalgrowth$growthrate[,1:(ncol(globalgrowth$growthrate)-1)],globalgrowth$ne,globalgrowth$tau))
effectiveSize(globalMCMC)

#plots

growth.plot(globalgrowth)+theme_bw()
neplot(globalgrowth)+theme_bw()

#save files
save(globalgrowth, file="global_covid")
load("global_covid")

#compare to phylodyn
GlobalBSP <- BNPR(resPoly, lengthout = 35, prec_alpha = 0.01, prec_beta = 0.01,
                  beta1_prec = 0.001, fns = NULL, log_fns = TRUE, simplify = TRUE,
                  derivative = FALSE, forward = TRUE)

#---------------------------
#Lineage A
#---------------------------

mcmcfit_c1 <- skygrowth.mcmc(Clade1nex, res = 35, tau0=0.1,tau_logprior = function (x) dexp(x,0.1,T), mhsteps= 1e+07, control=list(thin=1e3) ) #I get quite different results with this compared to the mcc

#check mcmc diagnostics -
c1 <- as.mcmc(cbind(mcmcfit_c1$growthrate[,1:(ncol(mcmcfit_c1$growthrate)-1)],mcmcfit_c1$ne,mcmcfit_c1$tau))
effectiveSize(c1)

#Plots

growth.plot( mcmcfit_c1 )+theme_bw()
neplot(mcmcfit_c1 )+theme_bw()

#compare to phylodynn
BSpsLin1<- BNPR(Clade1nex, lengthout = 35, prec_alpha = 0.01, prec_beta = 0.01,
                   beta1_prec = 0.001, fns = NULL, log_fns = TRUE, simplify = TRUE,
                   derivative = FALSE, forward = TRUE)
par(mar=c(5.1,4.1,4.1,2.1))
plot_BNPR(BSpsLin1)

#---------------------------
#Lineage B
#---------------------------

mcmcfit_l2 <- skygrowth.mcmc(Clade2nex, res = 20, tau0=0.1,tau_logprior = function (x) dexp(x,0.1,T), mhsteps= 1e+07, control=list(thin=1e3) ) 

#check convergence
l2mcmc <- as.mcmc(cbind(mcmcfit_l2$growthrate[,1:(ncol(mcmcfit_l2$growthrate)-1)],mcmcfit_l2$ne,mcmcfit_l2$tau))
effectiveSize(l2mcmc )

#Plots
neplot(mcmcfit_l2)+theme_bw()
growth.plot(mcmcfit_l2)+theme_bw()

#compare with Phylodynn
BSpsLin2<- BNPR(Clade2nex, lengthout = 35, prec_alpha = 0.01, prec_beta = 0.01, #lengthout = number of grid points
                   beta1_prec = 0.001, fns = NULL, log_fns = TRUE, simplify = TRUE,
                   derivative = FALSE, forward = TRUE)
par(mar=c(5.1,4.1,4.1,2.1))
plot_BNPR(BSpsLin2)


#---------------------------
#Lineage C
#---------------------------

mcmcfit_l3 <- skygrowth.mcmc(Clade3nex, res = 10, tau0=0.1,tau_logprior = function (x) dexp(x,0.1,T), mhsteps= 5e+06, control=list(thin=1e5) ) #was not converging with 35 grid points.  oved it back to 10 and it works

#check convergence

l3mcmc <- as.mcmc(cbind(mcmcfit_l3$growthrate[,1:(ncol(mcmcfit_l3$growthrate)-1)],mcmcfit_l3$ne,mcmcfit_l3$tau))
effectiveSize(c3mcmc)

save(mcmcfit_c3 , file="Lineage3_covid")
load("Lineage3_covid")

#Plots
growth.plot( mcmcfit_l3 )+theme_bw()
neplot(mcmcfit_l3 )+theme_bw()

# compare to phylodynn

BSpsLi3<- BNPR(Clade3nex, lengthout = 10, prec_alpha = 0.01, prec_beta = 0.01,
                   beta1_prec = 0.001, fns = NULL, log_fns = TRUE, simplify = TRUE,
                   derivative = FALSE, forward = TRUE)
par(mar=c(5.1,4.1,4.1,2.1))
plot_BNPR(BSpsLi3)

#------------------------------------------------------------------------
##################BEAST analysies##################
#------------------------------------------------------------------------

#Same analysis again for with BEAST trees (not included in paper)


#------------------------------------------------------------------------
##################Visualize MCC Tree##################
#------------------------------------------------------------------------
#import .tre file
beast <- read.beast('covid_combinedTree15May.tre')

#can read nexus too
b <-  read.nexus('covid_combinedTree15May.tre')


#can see node numbers
ph <- ggtree(beast) + geom_tiplab(size=2)+ geom_text2(aes(subset=!isTip, label=node), hjust=-.3) 
ph  

#add branch lengths etc
p1 <- ggtree(beast , mrsd="2020-03-24") + theme_tree2()+ 
  #geom_tiplab(align=FALSE, linetype='dashed', linesize=0.5, size=1) +  
  #geom_range("length_0.95_HPD", color='red', size=2, alpha=.5) + #gets length estimates 
  geom_text2(aes(label=round(as.numeric(posterior), 2), 
                 subset=as.numeric(posterior)> 0.8, 
                 x=branch), vjust=0)
p1

#can isolate particular sections of the tree
viewClade(ph+geom_tiplab(size=2), node=764)
#------------------------------------------------------------------------
##################look for non-random tree structure using treestructure (Volz et al)##################
#------------------------------------------------------------------------


#try min 10 for clade size 
treeSt <-  trestruct(b, minCladeSize = 145, minOverlap = -Inf, nsim = 10000,
                     level = 0.05, ncpu = 1, verbosity = 1) 
#20 gets 12 groups - too many?
#50-200 stable 3 groups. >200 1 group (nearly 50% of the sequences)
treeSt_df <- as.data.frame(treeSt)

plot(treeSt, use_ggtree = TRUE)

#----------------------------
#subset tree - to three lineages and plot each linage
#---------------------------

#Lineage A

tokeepc1<-setdiff(b$tip.label,names(treeSt$clustering)[which(treeSt$clustering==1)]) 
Clade1nex<-drop.tip(resPoly,tokeepc1)



# going forward in the tree to remove weird outliers
ggtree(Clade1nex) + geom_tiplab(size=2)+ geom_text2(aes(subset=!isTip, label=node), hjust=-.3) 


Clade1_names <- as.data.frame(get_taxa_name(tree_view = NULL, node = NULL))



#Lineage C

tokeepc3BEAST<-setdiff(b$tip.label,names(treeSt$clustering)[which(treeSt$clustering==2)])
Clade3nexBEAST<-drop.tip(b,tokeepc3BEAST)

ggtree(Clade3nexBEAST) + geom_tiplab(size=2)+ geom_text2(aes(subset=!isTip, label=node), hjust=-.3) #complete tree


#------------------------------------------------------------------------
##################Skygrowth models and phylodynn effective pop size##################
#------------------------------------------------------------------------

#--------------------------------------------------------------
#Global models (ie. using all sequences rather than partitions)
#--------------------------------------------------------------

maplGlobal <- skygrowth.map(resPoly, res = 35, tau0=0.1,tau_logprior = function (x) dexp(x,0.1,T)) #res=35

globalgrowth <- skygrowth.mcmc(b, res = 35, tau0=0.1,tau_logprior = function (x) dexp(x,0.1,T), mhsteps= 2e+07, control=list(thin=1e3) ) 

#check convergence
globalMCMC <- as.mcmc(cbind(globalgrowth$growthrate[,1:(ncol(globalgrowth$growthrate)-1)],globalgrowth$ne,globalgrowth$tau))
effectiveSize(globalMCMC)

#plots
growth.plot(maplGlobal)+theme_bw()
growth.plot(globalgrowth)+theme_bw()
neplot(globalgrowth)+theme_bw()
R.plot(globalgrowth, forward=TRUE, gamma=0.90)+theme_bw()

#save files
save(globalgrowth, file="global_covid")
load("global_covid")

#compare to phylodyn
GlobalBSP <- BNPR(resPoly, lengthout = 35, prec_alpha = 0.01, prec_beta = 0.01,
                  beta1_prec = 0.001, fns = NULL, log_fns = TRUE, simplify = TRUE,
                  derivative = FALSE, forward = TRUE)

#---------------------------
#Lineage A
#---------------------------

mcmcfit_c1 <- skygrowth.mcmc(Clade1nex, res = 35, tau0=0.1,tau_logprior = function (x) dexp(x,0.1,T), mhsteps= 1e+07, control=list(thin=1e3) ) #I get quite different results with this compared to the mcc
growth.plot( mcmcfit_c1 )+theme_bw()
neplot(mcmcfit_c1 )+theme_bw()

R.plot(mcmcfit_c1 , forward=TRUE, gamma=0.90)+theme_bw()# Maybe something from https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0230405. Doesn't seem to be realistic though

#check mcmc diagnostics -
c1 <- as.mcmc(cbind(mcmcfit_c1$growthrate[,1:(ncol(mcmcfit_c1$growthrate)-1)],mcmcfit_c1$ne,mcmcfit_c1$tau))
effectiveSize(c1)

#compare to phylodynn
BSpsLin1<- BNPR(Clade1nex, lengthout = 35, prec_alpha = 0.01, prec_beta = 0.01,
                beta1_prec = 0.001, fns = NULL, log_fns = TRUE, simplify = TRUE,
                derivative = FALSE, forward = TRUE)
par(mar=c(5.1,4.1,4.1,2.1))
plot_BNPR(BSpsLin1)

#---------------------------
#Lineage B
#---------------------------

mapl2 <- skygrowth.map(Clade2nex, res = 35, tau0=0.1,tau_logprior = function (x) dexp(x,0.1,T)) 

mcmcfit_l2 <- skygrowth.mcmc(Clade2nex, res = 35, tau0=0.1,tau_logprior = function (x) dexp(x,0.1,T), mhsteps= 1e+07, control=list(thin=1e3) ) 
growth.plot( mcmcfit_l2 )+theme_bw()

#check convergence
l2mcmc <- as.mcmc(cbind(mcmcfit_l2$growthrate[,1:(ncol(mcmcfit_l2$growthrate)-1)],mcmcfit_cl$ne,mcmcfit_l2$tau))
effectiveSize(l2mcmc )

#Plots
neplot(mcmcfit_l2)+theme_bw()
growth.plot(mapl2)+theme_bw()
growth.plot(v)+theme_bw()

#compare with Phylodynn
BSpsLin2<- BNPR(Clade2nex, lengthout = 35, prec_alpha = 0.01, prec_beta = 0.01, #lengthout = number of grid points
                beta1_prec = 0.001, fns = NULL, log_fns = TRUE, simplify = TRUE,
                derivative = FALSE, forward = TRUE)
par(mar=c(5.1,4.1,4.1,2.1))
plot_BNPR(BSpsLin2)


#---------------------------
#Lineage C
#---------------------------

#has an extra sequence from 
mapl3 <- skygrowth.map(Clade3nexBEAST, res = 10, tau0=0.1,tau_logprior = function (x) dexp(x,0.1,T)) #try res = 10 as more recent

mcmcfit_l3BEAST <- skygrowth.mcmc(Clade3nexBEAST, res = 10, tau0=0.1,tau_logprior = function (x) dexp(x,0.1,T), mhsteps= 2e+07, control=list(thin=1e3) ) #was not converging with 35 grid points.  oved it back to 10 and it works

#check convergence

l3mcmcB <- as.mcmc(cbind(mcmcfit_l3BEAST$growthrate[,1:(ncol(mcmcfit_l3BEAST$growthrate)-1)],mcmcfit_l3BEAST$ne,mcmcfit_l3BEAST$tau))
effectiveSize(l3mcmcB)

save(mcmcfit_l3BEAST , file="Lineage3_covidBEAST")
load("Lineage3_covidBEAST")

#Plots
growth.plot( mapl3  )+theme_bw()
growth.plot( mcmcfit_l3BEAST )+theme_bw()
neplot(mcmcfit_l3BEAST )+theme_bw()

# compare to phylodynn

BSpsLi3B<- BNPR(Clade3nexBEAST, lengthout = 10, prec_alpha = 0.01, prec_beta = 0.01,
               beta1_prec = 0.001, fns = NULL, log_fns = TRUE, simplify = TRUE,
               derivative = FALSE, forward = TRUE)
par(mar=c(5.1,4.1,4.1,2.1))
plot_BNPR(BSpsLi3B)

#----------------------------
#Extracting sequences from each clade - not used in the manuscript 
#---------------------------
library(ggmsa)
library(Biostrings) 
library(DECIPHER) 
library(tidyverse)
library(ape)

#BiocManager::install("DECIPHER") #etc
dna <- readDNAStringSet("covid_alignment.fasta")

dnadf <- as.data.frame(readDNAStringSet("covid_alignment.fasta"))

dnaNN <- tibble::rownames_to_column(dnadf, "seq")


clade_1seq <- dnaNN %>% 
  filter( dnaNN$seq %in% Clade1_names$seq )


row.names(clade_1seq) <- as.character(clade_1seq$seq)
 SeqNames <- clade_1seq$seq
clade_1seq$seq <- NULL

names(clade_1seq) <- 'dna'
clade_1seqMat <- as.matrix(clade_1seq)


clade1seqB <-DNAStringSet(clade_1seqMat, use.names=TRUE)
clade1seqB@ranges@NAMES <- SeqNames

#make it a string again! problem here with the names
clade_1seqMatNames <- cbind(clade1seqB,  SeqNames)

library(tigger)
writeFasta(clade1seqB, file= "clade1seq.fasta ")
#re-align - not needed

clade_1seqNG <- RemoveGaps(clade1seqB , "all")# why it wants gaps removed?
alignedC1 <- AlignSeqs(clade_1seqNG)

# view the alignment in a browser (optional)
BrowseSeqs(alignedC1, highlight=0) #awful alignment. 

#----------------------------
#Selection using CorMut/Ape
#---------------------------

# dNdS - works but not sure how to sue the reusltant matrix
#convert to right format
clade1dN <- as.DNAbin(clade1seqB ) #may need to add a extra consensus sequence.

C1dnds <-  dnds( clade1dN  , code = 1, codonstart = 1, quiet = FALSE)


library(CorMut) #doesn't work as failing to load. Moving to FUBAR in datamonkey.
file <- system.file("clade1seq.fasta",package="CorMut")

file <- system.file('C:/Users/Nick FJ/Documents/Covid19/clade1seq.fasta')

clade1dN <- seqFormat(file, format = c("fasta"))

result <- kaksCodon(clade1seqB)

fresult <-  filterSites(result)
head(fresult)


#useful code  
ex.dna <- read.dna("covid_alignment.fasta", format = "fasta")
names(ex.dna)
ggmsa(ex.dna) , color = "Chemistry_NT")

#converting dates

x <- c(2019.85)
library(lubridate)
(f <- format(date_decimal(x), "%d-%m-%Y"))
